# Autosar Classic Platform ScheduleTable 调度表

## 周期任务调度概要
Autosar Classic Platform OS的周期任务均采用静态配置，它们的调度主要通过Alarm和ScheduleTable两种方式实现。
这两种方式均为时间触发，因此，需要依赖于系统时钟，通常由硬件计时器、驱动程序配合产生。
Alarm机制通常与任务数量一一对应，每个Alarm需要引用自身所在核心的系统时钟，当设定的时钟到来时，Alarm可激活任务。
因此，实现多任务调度时，每个核心需建立多个Alarm用于任务激活。

ScheduleTable机制则通过构造调度表，表中设置到期点（Expiry Points），每个到期点挂载多个任务，当时钟到达到期点时，激活这些任务。
每个调度表均需要绑定到一个系统时钟上，单个系统时钟可驱动多个调度表。
一个周期任务只能绑定在一个调度表中，但调度表可以管理多个周期任务。

调度表和Alarm有如下特点：

| 特性 |	调度表（Schedule Table）|	报警器（Alarm）|
| --- | --- | --- |
| 任务管理	| 支持多任务管理 | 仅支持单任务管理 |
| 同步机制	| 支持调度表之间的同步	| 不支持复杂同步机制 |
| 配置复杂度 |	复杂 |	简单 |
| 资源占用	| 较高（每个调度表需要一个计数器）|	较低（每个报警器需要一个计数器）|
| 时间精度	| 高 |	依赖于计数器的精度 |
| 适用场景	| 多任务、严格时间同步、短周期任务 |	单任务、独立任务、长周期任务 |


## 调度表的基本原理
#### 基本执行
如图1所示，调度表中存在多个偏移量（Offset）不同的到期点，到期点钟可以挂在多个周期任务或者事件任务。
系统执行时，时钟到达任意到期点的偏移量，即可激活到期点钟的任务执行。

<div align="center">
    <img src="img/scheduletable.png" alt="调度表基本原理" width="100%"/>
    <div>图1 调度表基本原理</div>
</div>

#### 调度表类型
单发（single-shot）：调度表按顺序处理每个到期点，然后在末端到期点执行完后停止。这对于在响应某个触发事件时触发分阶段的动作序列非常有用。

重复（repeated）: 调度表依次处理每个到期点，在处理完最后一个到期点后，它会回绕至初始到期点。这对于构建执行重复处理的应用程序或需要将处理与驱动源同步的系统非常有用。

#### 周期任务执行模型
利用重复调度表，可调度执行周期任务。假定存在$n$个周期任务，它们的周期分别为$t_1,t_2,...,t_n$。可求得调度表的周期为所有任务周期的最小公倍数$lcm(t_1,t_2,...,t_n)$。
因此，对于所有任务到期点的偏移量$Offset$（假定调度表起始点为0）可按如下代码求得
```
struct ExpiryPoint {
    int offset;
}

ExpiryPoint ep[MAX_NUM_EP];
int NumExpiryPoint = 0;

T = lcm(t_1,t_2,...,t_n);
for(time = 0; time < T; time++) {
    for(int i = 1; i < n; i++) {
        if(time % i == 0) {
            ep[NumExpiryPoint++].offset = time;
        }
    }
}
```
